use anyhow::{anyhow, Result};
use argon2::Argon2;
use base64::Engine;
use serde::{Deserialize, Serialize};
use std::path::Path;

const SERVICE_NAME: &str = "org.signal-tauri.Signal";
const KEYCHAIN_ACCOUNT: &str = "database-encryption-key";

#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub enum EncryptionMethod {
    AutoGenerated,
    Keychain,
    Password,
}

impl Default for EncryptionMethod {
    fn default() -> Self {
        Self::AutoGenerated
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EncryptionConfig {
    pub method: EncryptionMethod,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub salt: Option<String>,
}

impl Default for EncryptionConfig {
    fn default() -> Self {
        Self {
            method: EncryptionMethod::AutoGenerated,
            salt: None,
        }
    }
}

pub struct EncryptionProvider {
    config: EncryptionConfig,
    data_dir: std::path::PathBuf,
}

impl EncryptionProvider {
    pub fn new(data_dir: &Path, config: EncryptionConfig) -> Self {
        Self {
            config,
            data_dir: data_dir.to_path_buf(),
        }
    }

    pub fn method(&self) -> EncryptionMethod {
        self.config.method
    }

    pub fn get_key(&self, password: Option<&str>) -> Result<String> {
        match self.config.method {
            EncryptionMethod::AutoGenerated => self.get_auto_generated_key(),
            EncryptionMethod::Keychain => self.get_keychain_key(),
            EncryptionMethod::Password => {
                let pwd = password.ok_or_else(|| anyhow!("Password required"))?;
                self.derive_key_from_password(pwd)
            }
        }
    }

    pub fn setup(&mut self, password: Option<&str>) -> Result<String> {
        match self.config.method {
            EncryptionMethod::AutoGenerated => self.setup_auto_generated(),
            EncryptionMethod::Keychain => self.setup_keychain(),
            EncryptionMethod::Password => {
                let pwd = password.ok_or_else(|| anyhow!("Password required for setup"))?;
                self.setup_password(pwd)
            }
        }
    }

    pub fn is_configured(&self) -> bool {
        let app_db_exists = self.data_dir.join("app.db").exists();
        
        match self.config.method {
            EncryptionMethod::AutoGenerated => {
                self.data_dir.join(".encryption_key").exists() || app_db_exists
            }
            EncryptionMethod::Keychain => {
                match self.get_keychain_key() {
                    Ok(_) => true,
                    Err(e) => {
                        tracing::warn!("Keychain access failed: {}", e);
                        app_db_exists
                    }
                }
            }
            EncryptionMethod::Password => {
                self.config.salt.is_some()
            }
        }
    }

    pub fn config(&self) -> &EncryptionConfig {
        &self.config
    }

    fn get_auto_generated_key(&self) -> Result<String> {
        let key_path = self.data_dir.join(".encryption_key");
        if key_path.exists() {
            let key = std::fs::read_to_string(&key_path)?;
            Ok(key.trim().to_string())
        } else {
            Err(anyhow!("Encryption key not found. Run setup first."))
        }
    }

    fn setup_auto_generated(&self) -> Result<String> {
        let key_path = self.data_dir.join(".encryption_key");
        
        if key_path.exists() {
            return self.get_auto_generated_key();
        }

        let mut key_bytes = [0u8; 32];
        getrandom::fill(&mut key_bytes)?;
        let key = base64::engine::general_purpose::STANDARD.encode(&key_bytes);
        
        std::fs::write(&key_path, &key)?;
        tracing::info!("Generated new auto-generated encryption key");
        
        Ok(key)
    }

    fn get_keychain_key(&self) -> Result<String> {
        let entry = keyring::Entry::new(SERVICE_NAME, KEYCHAIN_ACCOUNT)?;
        entry.get_password().map_err(|e| anyhow!("Keychain access failed: {}", e))
    }

    fn setup_keychain(&self) -> Result<String> {
        let entry = keyring::Entry::new(SERVICE_NAME, KEYCHAIN_ACCOUNT)?;
        
        if let Ok(existing) = entry.get_password() {
            return Ok(existing);
        }

        let mut key_bytes = [0u8; 32];
        getrandom::fill(&mut key_bytes)?;
        let key = base64::engine::general_purpose::STANDARD.encode(&key_bytes);
        
        entry.set_password(&key)?;
        tracing::info!("Stored encryption key in system keychain");
        
        Ok(key)
    }

    fn derive_key_from_password(&self, password: &str) -> Result<String> {
        let salt_str = self.config.salt.as_ref()
            .ok_or_else(|| anyhow!("No salt configured. Run setup first."))?;
        
        let salt_bytes = base64::engine::general_purpose::STANDARD.decode(salt_str)?;
        
        let mut output = [0u8; 32];
        Argon2::default()
            .hash_password_into(password.as_bytes(), &salt_bytes, &mut output)
            .map_err(|e| anyhow!("Key derivation failed: {}", e))?;
        
        Ok(base64::engine::general_purpose::STANDARD.encode(&output))
    }

    fn setup_password(&mut self, password: &str) -> Result<String> {
        if self.config.salt.is_some() {
            return self.derive_key_from_password(password);
        }

        let mut salt_bytes = [0u8; 16];
        getrandom::fill(&mut salt_bytes)?;
        self.config.salt = Some(base64::engine::general_purpose::STANDARD.encode(&salt_bytes));
        
        tracing::info!("Generated new salt for password-based encryption");
        
        self.derive_key_from_password(password)
    }

    pub fn clear_keychain() -> Result<()> {
        let entry = keyring::Entry::new(SERVICE_NAME, KEYCHAIN_ACCOUNT)?;
        entry.delete_credential().map_err(|e| anyhow!("Failed to delete keychain entry: {}", e))
    }

    pub fn change_password(&mut self, old_password: &str, new_password: &str) -> Result<(String, String)> {
        if self.config.method != EncryptionMethod::Password {
            return Err(anyhow!("Password change only available for password-based encryption"));
        }

        let old_key = self.derive_key_from_password(old_password)?;
        
        let mut salt_bytes = [0u8; 16];
        getrandom::fill(&mut salt_bytes)?;
        self.config.salt = Some(base64::engine::general_purpose::STANDARD.encode(&salt_bytes));
        
        let new_key = self.derive_key_from_password(new_password)?;
        
        Ok((old_key, new_key))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_auto_generated_setup_and_get() {
        let dir = tempdir().unwrap();
        let config = EncryptionConfig {
            method: EncryptionMethod::AutoGenerated,
            salt: None,
        };
        let mut provider = EncryptionProvider::new(dir.path(), config);
        
        let key1 = provider.setup(None).unwrap();
        let key2 = provider.get_key(None).unwrap();
        
        assert_eq!(key1, key2);
        assert!(!key1.is_empty());
    }

    #[test]
    fn test_password_setup_and_get() {
        let dir = tempdir().unwrap();
        let config = EncryptionConfig {
            method: EncryptionMethod::Password,
            salt: None,
        };
        let mut provider = EncryptionProvider::new(dir.path(), config);
        
        let key1 = provider.setup(Some("my-secret-password")).unwrap();
        let key2 = provider.get_key(Some("my-secret-password")).unwrap();
        
        assert_eq!(key1, key2);
        
        let wrong_key = provider.get_key(Some("wrong-password")).unwrap();
        assert_ne!(key1, wrong_key);
    }

    #[test]
    fn test_password_requires_password() {
        let dir = tempdir().unwrap();
        let config = EncryptionConfig {
            method: EncryptionMethod::Password,
            salt: None,
        };
        let provider = EncryptionProvider::new(dir.path(), config);
        
        assert!(provider.get_key(None).is_err());
    }

    #[test]
    fn test_is_configured() {
        let dir = tempdir().unwrap();
        
        let config = EncryptionConfig {
            method: EncryptionMethod::AutoGenerated,
            salt: None,
        };
        let mut provider = EncryptionProvider::new(dir.path(), config);
        
        assert!(!provider.is_configured());
        provider.setup(None).unwrap();
        assert!(provider.is_configured());
    }
}
